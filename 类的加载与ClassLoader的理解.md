## 类的加载与ClassLoader的理解

> **加载：** 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，再生成一个代表这个类的java.lang.Class对象。
> **链接：** 将Java类的二进制代码合并到JVM运行状态中的过程。
>
> > - 验证：确保加载的类信息符合JVM规范，且没有安全方面的问题；
> >
> > - 准备：为static类变量分配内存，并设置其默认的初始值；
> >
> > - 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。
>
> **初始化：** 
>
> > - 执行类构造器<clinit>()方法的过程。由编译器自动收集类中静态代码块；
> >
> > - 当初始化一个类时，如果发现其父类没有被初始化，那么会优先初始化其父类；
> >
> > - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步。



## 什么时候会发生类的初始化？

> **类的主动引用（一定会发生类的初始化）** 
>
> > * 当虚拟机启动时，会初始化main方法中的所有类；
> > * new一个对象；
> > * 调用类的静态成员和静态方法；
> > * 使用java.lang.reflect包的方法对类进行反射；
> > * 当初始化一个类时，如果发现其父类没有被初始化，那么会优先初始化其父类。
>
> **类的被动引用（不会发生类的初始化）** 
>
> > * 当子类引用父类的静态变量时，不会导致子类的初始化；
> > * 当通过数组定义类引用时，不会触发类的初始化；
> > * 引用常量不会触发此类的初始化（常量在链接阶段就存入在调用类的常量池中）。



## 类加载器的作用

> **类加载的作用：** 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，再生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。
>
> **类缓存：** 标准的JavaSE类加载器可以按要求查找类。如果某个类被加载到类加载器中，那么它将维持一段时间（JVM垃圾回收机制可以回收这些Class对象）。

